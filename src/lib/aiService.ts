// AI Service - Real AI API Integration for Chatbot
// Supports multiple AI providers: OpenAI, Anthropic Claude, Google Gemini

interface AIMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

interface AIResponse {
  answer: string;
  provider: string;
  cached?: boolean;
}

// UTM Mandarin Club context for AI
const CLUB_CONTEXT = `You are an intelligent assistant for UTM Mandarin Club, a student organization at Universiti Teknologi Malaysia dedicated to promoting Mandarin language and Chinese culture.

KEY INFORMATION:

MEMBERSHIP & FEES:
- Students: RM50 per semester (4 months)
- Committee Members: FREE after admin verification
- Tutors: FREE after admin verification
- Payment methods: Bank transfer or credit/debit card
- Membership activates immediately after payment

LEVEL SYSTEM:
- 5 proficiency levels (Level 1: Beginner â†’ Level 5: Expert)
- Students start at Level 1
- Advance by passing assessments (70% minimum score)
- Payment does NOT increase level - only passing assessments does
- Tutors grade assessments

ATTENDANCE & CHECK-IN:
- Two methods: QR code scanning or session code entry
- QR codes generated by tutors (classes) and committee (events)
- Session codes are 6-character alphanumeric codes
- Each code can only be used once per person
- Attendance tracked in student dashboard

EVENTS & ACTIVITIES:
- Cultural workshops (calligraphy, tea ceremony)
- Language classes (regular Mandarin lessons)
- Festival celebrations (Chinese New Year, Mid-Autumn)
- Social events and networking
- Competitions (speech contests, talent shows)
- Students can RSVP through Events Calendar
- Notifications sent for venue changes and reminders

CLASSES:
- Weekly classes during semester
- Various locations on UTM campus (Language Learning Center, Student Activity Center)
- Tutors assigned to specific classes
- Check Events Calendar for specific schedules

USER ROLES:
- Students: Auto-approved, can attend classes, take assessments, view grades
- Committee: Requires admin verification, can create events, generate QR codes
- Tutors: Requires admin verification, can grade students, generate attendance QR codes
- Admin: Full access (login: utmmandarinclub@gmail.com)

TECHNICAL:
- Email verification required for all signups
- Committee/Tutor accounts need admin approval after email verification
- Students need to pay RM50 to access attendance, events, and assessments
- Without payment, students only see overview and membership tabs

CONTACT:
- Email: utmmandarinclub@gmail.com
- Location: UTM Campus
- Response time: 1-2 business days

IMPORTANT NOTES:
- Be friendly, helpful, and encouraging
- Use emojis appropriately to make responses engaging
- Provide clear, step-by-step instructions when explaining processes
- If you don't know something specific, direct users to contact the admin email
- Always promote learning and cultural appreciation
- Keep responses concise but comprehensive`;

export class AIService {
  private conversationHistory: Map<string, AIMessage[]> = new Map();
  private responseCache: Map<string, string> = new Map();
  
  // Get API key from environment or localStorage
  private getAPIKey(provider: 'openai' | 'anthropic' | 'gemini'): string | null {
    // Try environment variables first (with safety check)
    const env = typeof import.meta !== 'undefined' && import.meta.env ? import.meta.env : {};
    
    if (provider === 'openai') {
      return env.VITE_OPENAI_API_KEY || localStorage.getItem('openai_api_key') || null;
    } else if (provider === 'anthropic') {
      return env.VITE_ANTHROPIC_API_KEY || localStorage.getItem('anthropic_api_key') || null;
    } else if (provider === 'gemini') {
      return env.VITE_GEMINI_API_KEY || localStorage.getItem('gemini_api_key') || null;
    }
    return null;
  }

  // Set API key in localStorage
  setAPIKey(provider: 'openai' | 'anthropic' | 'gemini', apiKey: string) {
    localStorage.setItem(`${provider}_api_key`, apiKey);
  }

  // Call OpenAI GPT API
  private async callOpenAI(messages: AIMessage[]): Promise<string> {
    const apiKey = this.getAPIKey('openai');
    if (!apiKey) {
      throw new Error('OpenAI API key not configured');
    }

    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini', // Cost-effective model, can upgrade to gpt-4o for better quality
        messages: messages,
        temperature: 0.7,
        max_tokens: 500,
      })
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: { message: 'Unknown error' } }));
      throw new Error(error.error?.message || `OpenAI API error: ${response.status}`);
    }

    const data = await response.json();
    return data.choices[0]?.message?.content || 'No response generated';
  }

  // Call Anthropic Claude API
  private async callAnthropic(messages: AIMessage[]): Promise<string> {
    const apiKey = this.getAPIKey('anthropic');
    if (!apiKey) {
      throw new Error('Anthropic API key not configured');
    }

    // Convert messages format for Claude (exclude system message)
    const systemMessage = messages.find(m => m.role === 'system')?.content || '';
    const conversationMessages = messages.filter(m => m.role !== 'system');

    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': apiKey,
        'anthropic-version': '2023-06-01'
      },
      body: JSON.stringify({
        model: 'claude-3-haiku-20240307', // Fast and cost-effective
        max_tokens: 500,
        system: systemMessage,
        messages: conversationMessages
      })
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: { message: 'Unknown error' } }));
      throw new Error(error.error?.message || `Anthropic API error: ${response.status}`);
    }

    const data = await response.json();
    return data.content[0]?.text || 'No response generated';
  }

  // Call Google Gemini API
  private async callGemini(messages: AIMessage[]): Promise<string> {
    const apiKey = this.getAPIKey('gemini');
    if (!apiKey) {
      throw new Error('Gemini API key not configured');
    }

    // Convert messages to Gemini format
    const systemMessage = messages.find(m => m.role === 'system')?.content || '';
    const conversationMessages = messages.filter(m => m.role !== 'system');
    
    const contents = conversationMessages.map(msg => ({
      role: msg.role === 'assistant' ? 'model' : 'user',
      parts: [{ text: msg.content }]
    }));

    const response = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: contents,
          systemInstruction: {
            parts: [{ text: systemMessage }]
          },
          generationConfig: {
            temperature: 0.7,
            maxOutputTokens: 500,
          }
        })
      }
    );

    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: { message: 'Unknown error' } }));
      throw new Error(error.error?.message || `Gemini API error: ${response.status}`);
    }

    const data = await response.json();
    return data.candidates[0]?.content?.parts[0]?.text || 'No response generated';
  }

  // Main method to ask the AI
  async ask(question: string, userId: string = 'default'): Promise<AIResponse> {
    try {
      // Check cache first
      const cacheKey = question.toLowerCase().trim();
      if (this.responseCache.has(cacheKey)) {
        return {
          answer: this.responseCache.get(cacheKey)!,
          provider: 'cache',
          cached: true
        };
      }

      // Get or initialize conversation history
      if (!this.conversationHistory.has(userId)) {
        this.conversationHistory.set(userId, [
          {
            role: 'system',
            content: CLUB_CONTEXT
          }
        ]);
      }

      const history = this.conversationHistory.get(userId)!;
      
      // Add user message
      history.push({
        role: 'user',
        content: question
      });

      // Keep only last 10 messages (5 exchanges) to manage token usage
      const systemMessage = history.find(m => m.role === 'system');
      const recentMessages = history.filter(m => m.role !== 'system').slice(-10);
      const messages = systemMessage ? [systemMessage, ...recentMessages] : recentMessages;

      let answer: string;
      let provider: string;

      // Try providers in order of preference
      try {
        // Try OpenAI first (best quality)
        answer = await this.callOpenAI(messages);
        provider = 'OpenAI GPT-4o-mini';
      } catch (openaiError: any) {
        // Silently try next provider
        try {
          // Try Anthropic Claude
          answer = await this.callAnthropic(messages);
          provider = 'Anthropic Claude';
        } catch (anthropicError: any) {
          // Silently try next provider
          try {
            // Try Google Gemini (has free tier)
            answer = await this.callGemini(messages);
            provider = 'Google Gemini';
          } catch (geminiError: any) {
            // All providers failed
            throw new Error('NO_API_KEY_CONFIGURED');
          }
        }
      }

      // Add assistant response to history
      history.push({
        role: 'assistant',
        content: answer
      });

      // Update conversation history
      this.conversationHistory.set(userId, history);

      // Cache the response
      this.responseCache.set(cacheKey, answer);

      return {
        answer,
        provider,
        cached: false
      };

    } catch (error: any) {
      // Don't log errors to console - let the caller handle them
      throw error;
    }
  }

  // Clear conversation history for a user
  clearHistory(userId: string = 'default') {
    this.conversationHistory.delete(userId);
  }

  // Clear response cache
  clearCache() {
    this.responseCache.clear();
  }

  // Check if any provider is configured
  isConfigured(): boolean {
    return !!(
      this.getAPIKey('openai') || 
      this.getAPIKey('anthropic') || 
      this.getAPIKey('gemini')
    );
  }

  // Get configured provider
  getConfiguredProvider(): string | null {
    if (this.getAPIKey('openai')) return 'OpenAI';
    if (this.getAPIKey('anthropic')) return 'Anthropic';
    if (this.getAPIKey('gemini')) return 'Google Gemini';
    return null;
  }
}

export const aiService = new AIService();